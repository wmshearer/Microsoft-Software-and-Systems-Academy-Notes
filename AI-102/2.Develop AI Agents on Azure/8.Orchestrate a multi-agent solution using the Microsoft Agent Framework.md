# Microsoft Agent Framework — Multi-Agent Orchestration (Key Notes)

## Why multi-agent?
Some tasks are too big or too diverse for one agent. Multi-agent solutions let **specialized agents collaborate in the same conversation**, improving scalability, accuracy, and maintainability (ex: Monitoring → RCA → Deployment → Reporting in a DevOps pipeline).

---

## What is the Microsoft Agent Framework?
An **open-source SDK** for building AI-powered agents that:
- process user inputs
- make decisions
- execute tasks autonomously (LLM + traditional programming)
- collaborate with other agents via orchestration patterns

---

## Core concepts

### Agents
Intelligent, AI-driven entities that reason + execute tasks using:
- models
- tools
- conversation history

### Agent orchestration
A unified interface for coordinating multiple agents with different patterns, so you can switch patterns without rewriting agent logic.

### Chat clients
Provider-agnostic interface (via `BaseChatClient`) for Azure OpenAI, OpenAI, Anthropic, Foundry, etc.

### Tools & functions
Agents can auto-invoke tools:
- built-in: Code Interpreter, File Search, Web Search
- custom: your functions / external APIs

### Conversation management
Persistent context via `AgentThread`, with message roles:
- USER, ASSISTANT, SYSTEM, TOOL

---

## Workflow model in the framework

### Executors
Workers in a workflow (agents or custom logic components).

### Edges
Define message flow between executors:
- Direct (sequence)
- Conditional (branch)
- Switch-case (route)
- Fan-out (broadcast)
- Fan-in (merge)

### Events
Used for observability/debugging:
- `WorkflowStartedEvent`
- `WorkflowOutputEvent`
- `WorkflowErrorEvent`
- `ExecutorInvokeEvent`
- `ExecutorCompleteEvent`
- `RequestInfoEvent`

---

## Supported orchestration patterns

### 1) Concurrent
Run multiple agents **in parallel** on the same task; collect outputs.
Best for:
- brainstorming
- ensemble reasoning
- voting/quorum
Avoid when:
- strict ordering is required
- shared state updates would conflict
- quotas make parallel work expensive

### 2) Sequential
Pipeline: Agent A output → Agent B input → Agent C…
Best for:
- step-by-step workflows
- progressive refinement (draft → review → polish)
Avoid when:
- stages can be parallelized
- routing/iteration/backtracking is required

### 3) Group chat
Multiple agents (optionally a human) in one managed conversation.
A **chat manager** decides who speaks next.
Best for:
- debate/consensus
- maker-checker loops
- brainstorming with critique
Avoid when:
- speed is critical
- deterministic steps are required
Tip: keep to ~3 agents for easier control.

### 4) Handoff
One agent at a time; **control transfers dynamically** based on context.
Best for:
- expert routing (support escalation)
- multi-domain problems where needs emerge midstream
Avoid when:
- the order is known upfront
- routing is simple enough to hardcode
- risk of handoff loops is high

### 5) Magentic
Manager-driven, adaptive collaboration for complex, open-ended tasks.
Builds a task ledger + evolves plan in real-time.
Best for:
- complex problems with unknown solution path
- tasks needing planning artifacts + human review
Avoid when:
- fast, deterministic execution is needed

---

## Unified orchestration workflow (common across patterns)
1) Define agents and capabilities  
2) Select/create orchestration pattern (optional manager agent)  
3) (Optional) callbacks/transforms  
4) Start runtime  
5) Invoke orchestration with task  
6) Retrieve results asynchronously  

---

## Knowledge check answers

### 1) First step in unified orchestration workflow
✅ **Define your agents and describe their capabilities**

### 2) Best pattern for brainstorming + collaborative problem solving
✅ **Group Chat**

### 3) Pattern that dynamically transfers control based on context/rules
✅ **Handoff**
