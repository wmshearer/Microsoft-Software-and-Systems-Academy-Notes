# Model Context Protocol (MCP) and dynamic tool discovery

## Why MCP exists
AI agents often need to interact with external systems such as APIs, databases, or internal services. Manually wiring, updating, and maintaining these integrations becomes complex as systems scale or change.

Model Context Protocol (MCP) solves this by:
- Separating **tool management** from **agent logic**
- Allowing tools to be discovered dynamically at runtime
- Reducing redeployment and maintenance overhead

Key idea: *Agents discover and use tools on demand instead of having tools hardcoded.*

---

## What is dynamic tool discovery
Dynamic tool discovery allows an AI agent to:
- Query a centralized MCP server
- Retrieve a live catalog of available tools
- Invoke tools without prior hardcoded knowledge

Benefits:
- Tools can be added, updated, or removed centrally
- Agents always use the latest tool versions
- Agent code remains simple and stable

---

## Advantages of MCP for AI agents
Dynamic tool discovery:
- Integrate once, evolve continuously
- No agent redeployment for tool updates

Interoperability:
- MCP works across different LLMs
- You can switch models without redoing integrations

Standardized security:
- Centralized authentication
- No need to manage separate API keys per tool

---

## MCP architecture (high level)
MCP Server:
- Hosts tool definitions
- Exposes tools using `@mcp.tool`
- Acts as a live tool catalog

MCP Client:
- Connects to the MCP server
- Discovers tools dynamically
- Registers tools with the Azure AI Agent

Azure AI Agent:
- Uses discovered tools via natural language
- Decides when and how to invoke tools

---

## MCP server
- Initialized with something like `FastMCP("server-name")`
- Uses Python type hints and docstrings to define tools
- Serves tool metadata and execution endpoints over HTTP
- Can be updated without touching agent code

Key role:
- Central registry of executable tools

---

## MCP client
Acts as a bridge between the agent and MCP server.

Core responsibilities:
- Discover tools using `session.list_tools()`
- Generate function wrappers for each tool
- Register those tools with the agent

Key behavior:
- Tools appear to the agent like native functions
- No hardcoded integrations

---

## Registering MCP tools with an agent (client-managed flow)
General flow:
- MCP server hosts tools
- MCP client connects to server
- Client fetches tools dynamically
- Each tool is wrapped in an async function
- Wrapped tools are bundled into a `FunctionTool`
- FunctionTool is registered with the agent

Async requirement:
- Enables non-blocking tool invocation
- Allows agents to run efficiently

---

## Using MCP servers directly with Azure AI Agent Service
When using Microsoft Foundry Agent Service:
- You do NOT manually create MCP client sessions
- You do NOT manually wrap tools

Instead:
- Create an MCP tool object
- Provide MCP server metadata at run time
- Agent automatically discovers and invokes tools

---

## Remote MCP server integration
To connect an agent to an MCP server, you define:
- `server_label` → Friendly identifier (example: "GitHub")
- `server_url` → MCP server endpoint
- `allowed_tools` (optional) → Restrict accessible tools

Headers can be passed dynamically:
- API keys
- OAuth tokens
- Other required headers

Headers:
- Are applied per run
- Are NOT persisted between runs

---

## MCP tool invocation and approvals
MCP tools can be invoked automatically during an agent run.

Approval modes:
- `always` (default): developer approval required for each call
- `never`: no approval required

If approval is required:
- Run status becomes `requires_action`
- Tool name and arguments are surfaced
- Developer approves or denies execution

---

## Why MCP matters architecturally
- Clean separation of concerns
- Scales to many tools and teams
- Reduces coupling between agents and services
- Enables rapid evolution of agent capabilities

MCP is foundational for:
- Large agent ecosystems
- Rapidly changing APIs
- Enterprise-grade AI agent platforms

---

# Module assessment answers

## Q1: What role does the MCP server play in the MCP agent tool integration?
Correct answer:
- Hosts tool definitions and makes them available for discovery by the client.

## Q2: How does an MCP client retrieve available tools from the MCP server?
Correct answer:
- By calling `session.list_tools()` to get the current tool catalog.

## Q3: Why should MCP tools be wrapped in async functions on the client-side?
Correct answer:
- To enable asynchronous invocation so the agent can call tools without blocking.
